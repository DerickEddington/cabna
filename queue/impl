; Users' responsibilities:
;  1) Nodes must not be in more than one queue at a time.
;  2) Nodes must not be in the same queue more than once.
;  3) The memory allocated by the OS for nodes must never be returned to the OS.
; This implementation assumes that users obey these responsibilities.

; TODO: Describe the purpose and limits of this concurrent queue implementation
; and that it's made just for Cabna.

%include "conv"
%include "queue/strucs"

global enqueue
global dequeue

extern bug


section .text

%define q         arg1  ; Used by both enqueue and dequeue.
%define item      arg2  ; Used by enqueue.
%define tail      arg3  ; Used by enqueue.
%define old_head  arg2  ; Used by dequeue.
%define new_head  arg3  ; Used by dequeue.



; enqueue:
;   Arguments: 1) pointer to queue; 2) pointer to queue_node
;   Returns: nothing
;   Destroys: rax, rbx, rcx, rdx, arg3
enqueue:
  ; Setup for the cmpxchg16b here, so the load of the queue's tail is as close
  ; as possible to the cmpxchg16b, to minimize the chance of concurrent
  ; interference.
  mov rdx, false
  mov rax, q
  mov rcx, true
  mov rbx, null
  ; Get the queue's tail at this moment.  It might change before we get to
  ; locking it, because of concurrent threads.
  mov tail, [q + queue.tail]
  cmp tail, null
  je .empty
  ; Atomically check if concurrent interference happened, and, if not, lock the
  ; tail node for our use.  If it's not locked and still q's tail, we can use
  ; it.  If it's locked and q's tail, another thread is using it in dequeue.  If
  ; it's no longer q's tail, we cannot use it.  The .tail_of field is also read
  ; and written, because the operation works on 16 bytes, and .tail_of follows
  ; .locked in memory.  The 16-byte operation is used to test both fields,
  ; instead of testing only .locked, because I think doing so reduces the chance
  ; of concurrent contention that would be more likely if the node was locked
  ; before checking if it's still q's tail.  We avoiding locking it if we don't
  ; need to.
  lock cmpxchg16b [tail + queue_node.locked]
  jne enqueue  ; Another processor interfered concurrently.

  ; Other threads cannot concurrently execute the rest of this procedure, for
  ; the same queue.  This is what enables the concurrency-safety of this queue
  ; implementation.

  ; The item node must be locked, because it becomes the queue's tail but it is
  ; not yet ready.  We assume the item node is already locked and its other
  ; fields are null, because dequeue leaves dequeued nodes in that state, and
  ; because queue_node fields are private and users must not mess with them.
  ; Because users must not put a node in more than one queue at a time, this
  ; procedure can assume the item node will not be accessed by other threads
  ; while we're using it.
  mov [q + queue.tail], item
  mov [tail + queue_node.next], item
  ; Unlock the old tail node as soon as possible, so other threads can use it
  ; ASAP, e.g. for other threads doing dequeue.
  mov qword [tail + queue_node.locked], false

.done:
  mov [item + queue_node.tail_of], q
  mov qword [item + queue_node.locked], false
  return

.empty:
  ; Insert as head and tail, atomically.
  mov rdx, null
  mov rax, null
  mov rcx, item
  mov rbx, item
  ; The queue's .tail field is also read and written by this 16-byte operation.
  ; Like above, the item node must be locked.
  lock cmpxchg16b [q + queue.head]
  jne enqueue  ; Another processor interfered concurrently.
  mov [item + queue_node.head_of], q
  jmp .done



; dequeue:
;   Arguments: 1) pointer to queue
;   Returns: 1) pointer to queue_node, or null if queue empty
;   Destroys: rax, rbx, rcx, rdx, arg1, arg2, arg3
dequeue:
  ; Setup for the cmpxchg16b here, so the load of the queue's head is as close
  ; as possible to the cmpxchg16b, to minimize the chance of concurrent
  ; interference.
  mov rdx, q
  mov rax, false
  mov rcx, null
  mov rbx, true
  ; Get the queue's head at this moment.  It might change before we get to
  ; locking it, because of concurrent threads.
  mov old_head, [q + queue.head]
  cmp old_head, null
  je .empty
  ; Atomically check if concurrent interference happened, and, if not, lock the
  ; head node for our use.  If it's not locked and still q's head, we can use
  ; it.  If it's locked and q's head, another thread is using it in enqueue.  If
  ; it's no longer q's head, we cannot use it.  The .locked field is also read
  ; and written, because the operation works on 16 bytes, and .locked follows
  ; .head_of in memory.
  lock cmpxchg16b [old_head + queue_node.head_of]
  jne dequeue  ; Another processor interfered concurrently.

  ; Other threads cannot concurrently execute the rest of this procedure, for
  ; the same queue.  This is what enables the concurrency-safety of this queue
  ; implementation.

  mov new_head, [old_head + queue_node.next]
  cmp new_head, null
  je .also_tail
  ; We can set this field without concern about new_head concurrently being
  ; accessed by other threads.  Concurrent dequeues cannot get to new_head yet.
  ; Concurrent enqueues have an item that cannot be new_head (users'
  ; responsibility), and have a tail that is not new_head, or the tail is
  ; new_head and the .head_of field is not accessed by enqueue and the
  ; new_head/tail remains locked until enqueue unlocks.  For this last case, our
  ; setting of .head_of can occur before or after enqueue unlocks, and either is
  ; fine because other waiting threads cannot proceed until both occur.
  mov [new_head + queue_node.head_of], q
  ; Set the queue's new head ASAP, so other threads can use it ASAP.
  mov [q + queue.head], new_head

.done:
  mov qword [old_head + queue_node.tail_of], null
  mov qword [old_head + queue_node.next], null
  ; The .locked field of the returned node, old_head, remains true.
  ; Enqueue relies on item nodes having the state dequeue returns them with.
  ; Return success.
  return old_head

.also_tail:
  ; Remove head and tail, atomically.
  mov rdx, old_head
  mov rax, old_head
  mov rcx, null
  mov rbx, null
  ; The queue's .tail field is also read and written by this 16-byte operation.
  ; Here, cmpxchg16b is used only for 16-byte write atomicity, not for
  ; comparison.
  lock cmpxchg16b [q + queue.head]
  jne bug  ; Head node is still locked, so unequal cmp not possible.
  jmp .done

.empty:
  ; Return failure.
  return null
