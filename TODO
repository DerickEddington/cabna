Use branch hint instruction prefixes.

Use pause instruction in spin-wait loops.

Investigate having a ring of free task queues, so that if one queue is locked,
the next is immediately tried, instead of just spin-waiting.

Investigate using xmm register for 128-bit atomic store for reseting queue.head
and .tail, instead of locked cmpxchg16b.  The unnecessary cmp and the lock would
be avoided.  I think the xmm register should be preserved by temporarily saving
it before using and then restoring.

task.rcvr and task.ridx can be consolidated into the same field, because tasks
are 128-byte aligned, pointers to them have 7 unused low bits which is more than
enough for ridx up to 11.  This gives another argument field.

What if the argX_R macros are changed so that they don't conflict with syscall
registers?  Or maybe they should follow the Unix ABI, except the return
register.

Explain why task.head_of and .tail_of fields are necessary.

Do some testing with only one thread, before implementing multiple threads.

Implement thread creation per number of processors, at program start-up.  This
will allow exploring parallelism, even though the thread creation design might
change in the future.  I think using Linux's clone is the way to go.

Make a simple Scheme-like interpreter written in assembly and using the task
queueing and execution facilities.  I think this is an easy step towards using
the parallel processing without having a compiler.  Useful parallel programs
(including a compiler) can be interpreted.

All instructions which set a register to 0 should use xor instead.

Is xor better than btr for unlocking nodes?

Investigate opportunities to optimize assembly source for speed and size, such
as "mov byte" instead of "mov qword".

Investigate whether using rsi as a temp is the best idea or not.  Why destroy it
if not necessary if arg3 or arg4 can be used instead?  Is using an rX register
slower than legacy registers?

Investigate what NASM directives are neccessary to make a shared library.
