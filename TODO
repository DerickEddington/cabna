Investigate rearanging procedures for static branch prediction.  "Predict
backward conditional branches to be taken.  Predict forward conditional branches
to be NOT taken."

"All branch targets should be 16-byte aligned."

"If the body of a conditional is not likely to be executed, it should be placed
in another part of the program. If it is highly unlikely to be executed and code
locality is an issue, the body of the conditional should be placed on a
different code page.  Careful arrangement of code can enhance cache and memory
locality.  Likely sequences of basic blocks should be laid out contiguously in
memory. This may involve pulling unlikely code, such as code to handle error
conditions, out of that sequence."

Use branch hint instruction prefixes.

"Choose instructions with shorter latencies and fewer micro-ops. Favor single
micro-operation instructions."

"Avoid prefixes, especially multiple non-0F-prefixed opcodes."

"Use the 32-bit versions of instructions in 64-bit mode to reduce code size
unless the 64-bit version is necessary to access 64-bit data or additional
registers.  When eight registers are sufficient for an algorithm, donâ€™t use the
registers that require an REX prefix. This will keep the code size smaller."

Use pause instruction in spin-wait loops.

Investigate assuming all Cabna code and data is in 32-bit address space, thus
allowing 32-bit operations instead of 64-bit.  Is it possible to ensure it is
located within 32-bit?

Review the optimization guidline points again.



Investigate having a ring of free task queues, so that if one queue is locked,
the next is immediately tried, instead of just spin-waiting.

Investigate using xmm register for 128-bit atomic store for reseting queue.head
and .tail, instead of locked cmpxchg16b.  The unnecessary cmp and the lock would
be avoided.  I think the xmm register should be preserved by temporarily saving
it before using and then restoring.

task.rcvr and task.ridx can be consolidated into the same field, because tasks
are 128-byte aligned, pointers to them have 7 unused low bits which is more than
enough for ridx up to 11.  This gives another argument field.

What if the argX_R macros are changed so that they don't conflict with syscall
registers?  Or maybe they should follow the Unix ABI, except the return
register.

Explain why task.head_of and .tail_of fields are necessary.

Do some testing with only one thread, before implementing multiple threads.

Implement thread creation per number of processors, at program start-up.  This
will allow exploring parallelism, even though the thread creation design might
change in the future.  I think using Linux's clone is the way to go.

Make a simple Scheme-like interpreter written in assembly and using the task
queueing and execution facilities.  I think this is an easy step towards using
the parallel processing without having a compiler.  Useful parallel programs
(including a compiler) can be interpreted.

Is xor better than btr for unlocking nodes?

Investigate opportunities to optimize assembly source for speed and size, such
as "mov byte" instead of "mov qword".

Investigate whether using rsi as a temp is the best idea or not.  Why destroy it
if not necessary if arg3 or arg4 can be used instead?  Is using an rX register
slower than legacy registers?

Investigate what NASM directives are neccessary to make a shared library.
