global exec_task

extern dequeue

%include "conv"


section .text

exec_task:
  mov arg1_r8, ttq_r15
  mov argr_r13, .cont
.get:
  jmp dequeue
.cont:
  mov cet_r14, ret1_r12
  cmp cet_r14, null
  jne [cet_r14 + task.exec]
  ; Else, try to take a task from another thread.
  mov arg1_r8, [arg1_r8 + queue.next]
  jmp .get



; Brainstorm -- What could a parallel evaluation of procedure arguments compile to?
; Expression: ((a) (task-arg1 (b 1)))

  alloc_task 1
  mov [ret1_r12 + task.need], 2
  mov [ret1_r12 + task.rcvr], whatever
  mov [ret1_r12 + task.ridx], whatever
  mov t1, ret1_r12

  alloc_task 0
  mov [ret1_r12 + task.exec], a
  ;mov [ret1_r12 + task.need], 0  ; Not needed because task gets enqueued already.
  mov [ret1_r12 + task.rcvr], t1
  mov [ret1_r12 + task.ridx], 0   ; ridx 0 is rcvr's exec field
  enqueue_task ret1_r12

  alloc_task 1
  mov arg1_r8, [cet_r14 + task.arg1]
  mov [ret1_r12 + task.exec], arg1_r8
  mov [ret1_r12 + task.need], 1
  mov [ret1_r12 + task.rcvr], t1
  mov [ret1_r12 + task.ridx], 1  ; ridx 1 is rcvr's arg1 field
  mov t2, ret1_r12

  alloc_task 1
  mov [ret1_r12 + task.exec], b
  ;mov [ret1_r12 + task.need], 0
  mov [ret1_r12 + task.rcvr], t2
  mov [ret1_r12 + task.ridx], 1
  mov [ret1_r12 + task.arg1], 1
  enqueue_task ret1_r12

  jmp exec_task



; Brainstorm -- What could returning a value to a waiting task, and checking if
; the waiting task is ready to be queued, and deallocating the currently
; executing task, compile to?  E.g. the b call above.  (define (b n) (+ 7 n))
b:
  mov arg1_r8, [cet_r14 + task.arg1]
  add arg1_r8, 7
  jmp supply

supply:
  mov arg2_r9, [cet_r14 + task.rcvr]
  mov arg3_r10, [cet_r14 + task.ridx]
  mov [arg2_r9 + task.exec + 8 * arg3_r10], arg1_r8
  dealloc_task cet_r14
  lock dec [arg2_r9 + task.need]
  jnz exec_task  ; rcvr needs more
  enqueue_task arg2_r9
  jmp exec_task
