global exec_task

extern dequeue

%include "conv"


section .text

exec_task:
  mov arg1_r8, ttq_r15
  mov argr_r13, .cont
.get:
  jmp dequeue
.cont:
  mov cet_r14, ret1_r12
  cmp cet_r14, null
  jne [cet_r14 + task.exec]
  ; Else, try to take a task from another thread.
  mov arg1_r8, [arg1_r8 + queue.next]
  jmp .get



; Brainstorm -- What could a parallel evaluation of procedure arguments compile to?
;               Expression: ((a) (task-arg1 (b 1)))
  alloc_task 1
  mov [ret1_r12 + task.need], 2
  mov [ret1_r12 + task.rcvr], whatever
  mov [ret1_r12 + task.ridx], whatever
  mov t1, ret1_r12

  alloc_task 0
  mov [ret1_r12 + task.exec], a
  ;mov [ret1_r12 + task.need], 0  ; Not needed because task gets enqueued already.
  mov [ret1_r12 + task.rcvr], t1
  mov [ret1_r12 + task.ridx], 0   ; ridx 0 is rcvr's exec field
  enqueue_task ret1_r12

  alloc_task 1
  mov arg1_r8, [cet_r14 + task.arg1]
  mov [ret1_r12 + task.exec], arg1_r8
  mov [ret1_r12 + task.need], 1
  mov [ret1_r12 + task.rcvr], t1
  mov [ret1_r12 + task.ridx], 1  ; ridx 1 is rcvr's arg1 field
  mov t2, ret1_r12

  alloc_task 1
  mov [ret1_r12 + task.exec], b
  ;mov [ret1_r12 + task.need], 0
  mov [ret1_r12 + task.rcvr], t2
  mov [ret1_r12 + task.ridx], 1
  mov [ret1_r12 + task.arg1], 1
  enqueue_task ret1_r12

  jmp exec_task
