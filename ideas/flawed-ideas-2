Lockfree Concurrently-used Queue:

struct queue {
  head = null (?)
  tail = start (?)
  start
  end
  ?wraped = false (?)
}

---------------------------------------------------------------------------------
|         | head >> |         |         |  last   | tail >> |         |         |
---------------------------------------------------------------------------------

if head = tail, no more space left, allocate more?

(Array of references to queues for different sizes, for the block allocation
component, will be implemented as an array of the above queue struct)


define enqueue ( queue* q , any item)

  ; Goal: Other threads have a chance of being able to concurrently enqueue and
  ; dequeue while a particular enqueue operation is currently working.  Only
  ; border cases should cause failure/retry/exclustion.

  ; Damn, I think the below is still flawed with a kind of ABA problem.
  ; I think it can still work somehow!

  ; Destroyed Registers: arg1-r wraped-r temp-r head-snap-r new-tail-r

  ; arg1-r = q
  ; arg2-r = item

  ; Invariant: start and end fields never change
  ; Invariant: tail is not allowed to pass head

  ;?! Do cmp operations have correct operand order?

  ; It's possible the "xadd [q.tail]" and the subsequent "add eax ,
  ; pointer-bytesize" will integer-wrap, because of modular-arithmetic, thus
  ; causing the new tail to be less than the snapshot of the head, thus screwing
  ; up the logic which depends on and assumes the invariant that this can't
  ; happen.  This is unacceptable, but probably extremely unlikely given a
  ; 64-bit address space.  Maybe there's a processor flag which indicates if
  ; there was integer-wrap, and then we can test for that and hopefuly deal with
  ; it in a way that preserves the lockfree consistency of the queue.  If no
  ; processor flag can help, I think (hope) the add-overflowed test solves it.

  mov wraped-r , false ; or [q.wraped]
  mov temp-r , pointer-bytesize
  mov head-snap-r , [q.head] ; snapshot, it might concurrently change, as an advance, which is ok.  But what if [q.head] overflows because of xadd  modular-arithmetic?!
  lock xadd [q.tail] , temp-r
  cmp temp-r , head-snap-r ; old [q.tail] now in temp-r
  jl when-wraped ; old [q.tail] < head-snap-r
  mov new-tail-r , temp-r
  add new-tail-r , pointer-bytesize
  cmp new-tail-r , temp-r
  jl add-overflowed ; new-tail-r < temp-r because of modular-arithmetic xadd overflow

cmp-new-tail-to-head-snapshot:
  ; cmp new-tail-r , head-snap-r ; not needed because of new "jl when-wrapped" above
  ; jng when-wraped              ; ditto
  cmp new-tail-r , [q.end]
  jl add-item
  je wrap-tail
  jg when-beyond

when-wraped:
  ; new-tail-r <= head-snap-r
  ;? cmp new-tail-r , head-snap-r
  jl add-item   ; new-tail-r < head-snap-r
  jmp when-full ; new-tail-r = head-snap-r

wrap-tail:
  mov new-tail-r , [q.start]
  mov wraped-r , true
  ; Could testing snapshot of [q.tail] here help with dealing with
  ; integer-wrapping issue mentioned above?
  jmp cmp-new-tail-to-head-snapshot

add-item:
  mov [new-tail-r] , item
  cmp wraped-r , true
  je reset-tail ; new-tail-r = [q.start]
success:
  mov arg1-r , true
  jmp argret-r
reset-tail:
  mov [q.wraped] , true
  lock xchg [q.tail] , new-tail-r
  jmp success

add-overflowed:
when-beyond:
when-full:
fail:
  mov arg1-r , false
  jmp argret-r



define dequeue ( TODO )
  ;? [q.head] must not be reset to [q.start] unless q is known to be ready/consistent/safe?
  ; Maybe needs to (atomically?) check [q.tail] or [q.head] to learn if q is in
  ; a read/consistent state? ... because enqueue might be messing with the q.










Alternate implementation idea: Use double-word compare-and-swap of head+tail sameness

define enqueue ( queue* q , any item)
  ; Atomically load two words, using cmpxchg16b
  mov rdx , 0
  mov rax , 0
  ;mov rcx , 0
  ;mov rbx , 0
  lock cmpxchg16b [q.head+tail]
  ;je bug ; Should not be possible because head and tail fields never null.
  ; Now rdx and rax registers hold values of head and tail fields.
try:
  ;TODO: Stuff to calculate if and where to add item...
  ; Compare captured head and tail to current values, and commit update if the same.
  ; rdx and rax hold captured head and tail.
  mov rcx , new-head
  mov rbx , new-tail
  lock cmpxchg16b [q.head+tail]
  jne try ; rdx and rax now hold newly-captured head and tail
  mov arg1-r , true
  jmp argret-r

