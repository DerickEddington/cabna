BITS 64
%define pointer_bytesize	8
	

struc thread
  .task_queue_head	resq	1
  .task_queue_tail	resq	1
endstruc

struc task
  .instruction	resq	1
  ;;??? .parent	resq	1
  .return_index	resq	1
  .ready_count	resq	1
  ;; variable amount of 64-bit fields for parameters follow
endstruc

struc block
  .next	resq	1
endstruc

struc task_queue
  .head		resq	1
  .tail		resq	1
  ;; variable amount of 64-bit fields for queue entries follow
endstruc


%define thread_r	TODO
%define task_r		rbp
%define call_stack_r	rsp


;; TODO: Initial development temporary ease: .data section has memory allocated for
;;       memory management sub-system
section .data
  free_blocks:	dq	free_0
  free_0:	dq	block00
  block00:
	%rep task_size
		dq	0
	%endrep


section .text

  executor_loop:
	; TODO
  block_gotten:

  get_block:
  ; rdi: requested size parameter
	mov		stack_for_size, [free_blocks + rdi * pointer_bytesize]
	mov		top, [stack_for_size + blocks_stack.top]
	cmp		top, stack_for_size
	je		allocate_block
	mov		neg, -pointer_bytesize
	lock xadd	[stack_for_size + blocks_stack.top], neg
	

;;; NOTE: Both of the bellow implementations of get_block are flawed because
;;;       what they atomically compare could be the same but inconsistency
;;;       could still be caused by another thread.
	
  get_block:
  ; rdi: requested size parameter
  ; rsi: pointer to pointer to next free block of requested size
  ; rax: first-retrieved pointer to next free block of requested size
  ; rdx: pointer to slot preceeding where rax points to
	mov		rsi, [free_blocks + rdi * pointer_bytesize]
	mov		rax, [rsi]
	cmp		rax, rsi
	je		allocate_block		; arg register must be the same
	mov		rdx, rax
	sub		rdx, pointer_bytesize
	lock cmpxchg	[rsi], rdx
	jmp		block_gotten
  allocate_block:
	; TODO

  ;; Alternate get_block which uses linked-list built-into blocks instead
  get_block2:
  ; rdi: requested size parameter
  ; rax: pointer to head of list of free blocks of requested size
  ; rsi: pointer to rest of list, or 0
	mov		rax, [free_blocks + rdi * pointer_bytesize]
	cmp		rax, 0
	je		allocate_block
	mov		rsi, [rax + block.next]
	lock cmpxchg	[free_blocks + rdi * pointer_bytesize], rsi
