;--- User may modify these. ----------------------------------------------------

%assign amount_threads 4

; The size of a thread's stack, except the initial thread's.
%assign call_stack_size 4 * 4096

; The amount of pre-allocated free task strucs per thread.
%assign statically_allocated_free_tasks 64

; The maximum amount, per thread, of free task strucs that can be in a thread's
; allocatable-tasks stack.  When this limit is reached, freed tasks are pushed
; in the shared allocatable-tasks stack.
%assign private_free_tasks_max 4096  ; 512 KB

%define statistics_collection

;--- Internal. Do not modify. --------------------------------------------------

; The amount of task strucs to allocate per mmap when more are needed.
%assign mmap_tasks  amount_threads * 2 * private_free_tasks_max

; These registers are reserved for the runtime system and must not be mutated by
; users.
%define exec_s_r15    r15   ; A thread's executable-tasks stack (upper 32 bits).
%define alloc_s_r15d  r15d  ; A thread's allocatable-tasks stack (lower 32 bits).
%define cet_r14       r14   ; A thread's currently executing task.


; Procedure call arguments, including return-instruction continuation.
%define arg1_rdi  rdi
%define ret_rsi   rsi


%macro proc 1
  align 16
  %1
%endmacro


%macro jmp_ret_to 2
  mov esi, %2  ; ret_rsi. Assumes the pointer is in 32-bit space.
  jmp %1
%endmacro

%macro jmp_ret 1
  jmp_ret_to %1, %%continuation
  %%continuation:
%endmacro


; Indirect jump, more efficiently.
%macro jmp_ind 1+
  likely jmp %1  ; NOTE: Intel documents say branch-hints are only for Jcc
                 ; instructions, but the use here seems to improve speed.
  ud2  ; help branch misprediction
%endmacro


; Branch hints.
%macro likely 1+
  db 0x3E
  %1
%endmacro

%macro unlikely 1+
  db 0x2E
  %1
%endmacro


; Instances of all the below struc types must be aligned at 8-byte boundary, so
; that loads and stores of the fields are atomic.  Instances of task and stack
; strucs must be aligned at 128-byte boundary, for processor bus locking
; efficiency.  Those statically allocated in the .data section are properly
; aligned, because the section is specified to be aligned at 128-byte and the
; strucs are specified to be aligned at 128-byte.  Because all the strucs have
; qword fields, this preserves the correct 8-byte alignment.  Because task
; strucs are 128 bytes long, this preserves the correct 128-byte alignment when
; they are located contiguously.  Task strucs dynamically allocated by mmap are
; properly aligned, because mmap allocates pages on page boundary.

; TODO?: The .need field could be the lower bits of the .next field, and the
; .ridx field could be the lower bits of the .rcvr field, because the .next and
; .rcvr fields are pointers to task strucs which are always 128-byte aligned
; which means the pointers don't need the lower 7 bits, which is enough for
; values up to 127 which is more than enough for .need and .ridx.  This would
; give 2 more argument fields, for which .need and .ridx values would range from
; 0 (.exec) to 13, which fits in 4 bits.

struc task
  .next:    resq 1
  .rcvr:    resq 1
  .ridx:    resq 1
  .need:    resq 1  ; Locked field, concurrently updated atomically.
  .exec:    resq 1
  .arg1:    resq 1
  .arg2:    resq 1
  .arg3:    resq 1
  .arg4:    resq 1
  .arg5:    resq 1
  .arg6:    resq 1
  .arg7:    resq 1
  .arg8:    resq 1
  .arg9:    resq 1
  .arg10:   resq 1
  .arg11:   resq 1
endstruc

%assign task.args task.exec

%if task_size != 128
  %warning "Task size " task_size " not 128."
%endif


; For executable-tasks stacks, a struc's .next field is not changed once
; initialized, which allows concurrent reading of it without locking.  For
; thread-private allocatable-tasks stacks, concurrent access doesn't occur, and
; the .next field is never used.  For the shared allocatable-tasks stack,
; concurrent access does occur, and the lowest bit of the .next field is the
; lock variable, and this is alright because the shared stack doesn't keep a
; pointer in .next.  The .size field is used only for thread-private
; allocatable-tasks stacks, but if statistics collection is enabled then the
; field is used for the executable-tasks stacks also.  The .need field is used
; only for executable-tasks stacks, with a special protocol for concurrent
; access.

struc stack
  .head: resq 1
  .next: resq 1
  .size: resq 1
  .need: resq 1
endstruc

%if stack_size > 128
  %error "Stack size " stack_size " greater than 128."
%endif




%ifdef statistics_collection

struc stats
  .exec_s_max:     resq 1
  .execute_calls:  resq 1
  .executed_mine:  resq 1
  .wait            resq 1
  .sched_calls:    resq 1
  .sched_mine:     resq 1
  .allocated:      resq 1
  .freed:          resq 1
  .exclusion:      resq 1
  .mmap:           resq 1
endstruc

%if stats_size > 128
  %error "Stats size " stats_size " greater than 128."
%endif

%define t_stats  ts_stats + alloc_s_r15d - ts_alloc_ss

%macro stat 1+
  %1
%endmacro

%else

%macro stat 1+
%endmacro

%endif




%if amount_threads < 1
  %fatal "amount_threads, " amount_threads ", less than 1."
%endif

%if call_stack_size < 16 * 1024
  %error "call_stack_size, " call_stack_size ", less than 16 KB."
%endif

%if call_stack_size % 4096 != 0
  %warning "call_stack_size, " call_stack_size ", not a multiple of page size."
%endif

%if statically_allocated_free_tasks < 2
  %fatal "statically_allocated_free_tasks, " statically_allocated_free_tasks ", less than 2."
%endif

%if statically_allocated_free_tasks > private_free_tasks_max
  %error "statically_allocated_free_tasks greater than private_free_tasks_max."
%endif

%if private_free_tasks_max < 1
  %error "private_free_tasks_max, " private_free_tasks_max ", less than 1."
%endif

%if mmap_tasks < 1
  %error "mmap_tasks, " mmap_tasks ", less than 1."
%endif

%if (mmap_tasks * task_size) % 4096 != 0
  %warning "mmap_tasks, " mmap_tasks ", size not a multiple of page size."
%endif
