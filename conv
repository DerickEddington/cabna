;--- User may modify these. ----------------------------------------------------

%assign amount_threads 4

; The size of a thread's stack, except the initial thread's.
%assign stack_size 4 * 4096

; The amount of pre-allocated free task strucs per thread.  Different programs
; will need different amounts depending on the program, and so possibly have to
; mmap, but we can provide enough here for many common programs.
%assign statically_allocated_free_tasks 64

; The amount of task strucs to allocate, per thread, per mmap when more are
; needed.
%assign mmap_tasks 2048  ; 256 KB


;--- Internal. Do not modify. --------------------------------------------------


; These registers are reserved for the runtime system and must not be mutated by
; users.
%define exec_q_r15    r15   ; A thread's executable-tasks queue (upper 32 bits).
%define alloc_q_r15d  r15d  ; A thread's allocatable-tasks queue (lower 32 bits).
%define cet_r14       r14   ; A thread's currently executing task.


; Procedure call arguments, including return-instruction continuation.
%define arg1_rdi  rdi
%define ret_rsi   rsi


%macro proc 1
  align 16
  %1
%endmacro


%macro jmp_ret_to 2
  mov esi, %2  ; ret_rsi. Assumes the pointer is in 32-bit space.
  jmp %1
%endmacro

%macro jmp_ret 1
  jmp_ret_to %1, %%continuation
  %%continuation:
%endmacro


; Indirect jump, more efficiently.
%macro jmp_ind 1+
  likely jmp %1  ; NOTE: Intel documents say branch-hints are only for Jcc
                 ; instructions, but the use here seems to improve speed.
  ud2  ; help branch misprediction
%endmacro


; Branch hints.
%macro likely 1+
  db 0x3E
  %1
%endmacro

%macro unlikely 1+
  db 0x2E
  %1
%endmacro


; Instances of all the below struc types must be aligned at 8-byte boundary, so
; that loads and stores of the fields are atomic.  Instances of task and queue
; strucs must be aligned at 128-byte boundary, for processor bus locking
; efficiency.  Those statically allocated in the .data section are properly
; aligned, because the section is specified to be aligned at 128-byte and the
; strucs are specified to be aligned at 128-byte.  Because all the strucs have
; qword fields, this preserves the correct 8-byte alignment.  Because task
; strucs are 128 bytes long, this preserves the correct 128-byte alignment when
; they are located contiguously.  Task strucs dynamically allocated by mmap are
; properly aligned, because mmap allocates pages on page boundary.

; TODO?: The .need field could be the lower bits of the .next field, and the
; .ridx field could be the lower bits of the .rcvr field, because the .next and
; .rcvr fields are pointers to task strucs which are always 128-byte aligned
; which means the pointers don't need the lower 7 bits, which is enough for
; values up to 127 which is more than enough for .need and .ridx.  This would
; give 2 more argument fields, for which .need and .ridx values would range from
; 0 (.exec) to 13, which fits in 4 bits.

struc task
  .next:    resq 1
  .rcvr:    resq 1
  .ridx:    resq 1
  .need:    resq 1  ; Locked field, concurrently updated atomically.
  .exec:    resq 1
  .arg1:    resq 1
  .arg2:    resq 1
  .arg3:    resq 1
  .arg4:    resq 1
  .arg5:    resq 1
  .arg6:    resq 1
  .arg7:    resq 1
  .arg8:    resq 1
  .arg9:    resq 1
  .arg10:   resq 1
  .arg11:   resq 1
endstruc

%assign task.args task.exec

%if task_size != 128
  %warning "Task size " task_size " not 128."
%endif


; For executable-tasks queues, a queue struc's .next pointer is not changed once
; initialized, which allows concurrent reading of it without locking.  The
; lowest bit of the .next field is the lock variable for accessing the .head or
; .tail fields, and this is alright because all queue strucs are aligned such
; that pointers never need the lowest bit.  For allocatable-tasks queues,
; concurrent access doesn't occur, the .next field is never used, and there is
; no lock for accessing the .head or .tail fields.

struc queue
  .next: resq 1
  .head: resq 1
  .tail: resq 1
endstruc




%if amount_threads < 1
  %fatal "amount_threads, " amount_threads ", less than 1."
%endif

%if stack_size < 16 * 1024
  %error "stack_size, " stack_size ", less than 16 KB."
%endif

%if stack_size % 4096 != 0
  %warning "stack_size, " stack_size ", not a multiple of page size."
%endif

%if statically_allocated_free_tasks < 2
  %fatal "statically_allocated_free_tasks, " statically_allocated_free_tasks ", less than 2."
%endif

%if mmap_tasks < 1
  %error "mmap_tasks, " mmap_tasks ", less than 1."
%endif

%if (mmap_tasks * task_size) % 4096 != 0
  %warning "mmap_tasks, " mmap_tasks ", size not a multiple of page size."
%endif
